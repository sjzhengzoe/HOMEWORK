# 1、Vue 3.0 性能提升主要是通过哪几方面体现的？
## 响应式系统升级
    2.x 使用 defineProperty 实现响应式
    需要在初始化的时候就对诶一个对象遍历设置响应式
3.0 使用 Proxy 对象实现响应式
    不需要初始化的时候遍历设置响应式
    可以监听动态新增的属性
    可以监听删除的属性
    可以监听数组的索引和length
## 编译优化
2.x 通过标记静态根节点，优化 diff 的过程
3.0 标记和提升所有的静态根节点，diff的时候只需要对比动态节点内容
    Fragments 引入片段的概念 不需要一个唯一的根节点
    静态提升(静态的节点提升，下次直接复用，不进行对比)
    Patch flag(动态节点标记类型，例如有属性和文本，则下次diff的时候只是进行比较属性和文本)
    缓存时间处理函数(第一次渲染的时候缓存了函数，在重新渲染的时候直接从缓存获取函数，但是在执行函数的的时候再去获取最新的函数)
## 源码体积的优化
3.0 移除了一些不常用的API
    例如 inline-template、filter等
    Tree-shaking(除了core和响应式 都是按需引入和打包)

# 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
是在props被解析完毕 但是在组件实例被创建实例化之前执行 所以无法通过this获取实例、数据等
该函数返回的数据不是响应式的 需要通过reactive 使其变成响应式

reactive toRefs ref 等的使用方式不同 实现原理不同
具体 在 https://www.yuque.com/docs/share/035dccb8-f074-4850-a401-6d002b11bb08?#

# 3、Proxy 相对于 Object.defineProperty 有哪些优点？
Proxy对象实现属性监听
多层属性嵌套 在访问属性过程中处理下一级属性
默认监听动态添加的属性
默认监听属性的删除操作
默认监听数组索引和length属性
可以作为单独的模块使用

2.x中初始化的时候就需要在初始化的时候就对每一个对象遍历设置响应 递归调用Object.defineProperty
但是在3.0中 可以减少这样的操作 因为是在调用的时候进行的

# 4、Vue 3.0 在编译方面有哪些优化？
Fragments 引入片段的概念 不需要一个唯一的根节点
静态提升(静态的节点提升，下次直接复用，不进行对比)
Patch flag(动态节点标记类型，例如有属性和文本，则下次diff的时候只是进行比较属性和文本)
缓存时间处理函数(第一次渲染的时候缓存了函数，在重新渲染的时候直接从缓存获取函数，但是在执行函数的的时候再去获取最新的函数)


# 5、Vue.js 3.0 响应式系统的实现原理？
主要通过设置Proxy对象来实现 当获取数据的时候进行收集依赖 当更改数据的时候触发更新
主要总结在 ./notes/内容总结.xmind 中