# 简答题

## 1. 请说出下列最终执行结果，并解释为什么?

var a = [];
for (var i = 0; i < 10; i++) {
a[i] = function () {
console.log(i);
};
}
a[6]();
回答：10
因为 var 不会产生块级作用域，所以在执行 a[6]()的时候，还是通过声明函数的作用域去获取 i 的值，此时 i 的值经过 for 循环已经变成了 10。

## 2. 请说出此案列最终执行结果，并解释为什么?

var tmp = 123;
if (true) {
console.log(tmp);
let tmp;
}
回答：会报错
因为 let 会产生块级作用域，并且 let 不允许在声明前就使用变量，所以 console.log(tmp)的时候，tmp 还没有定义，于是报错。

## 3. 结合 ES6 语法，用最简单的方式找出数组中的最小值

var arr = [12, 34, 32, 89, 4];
回答：Math.min(...arr)

## 4. 请详细说明 var、let、const 三种声明变量的方式之间的具体差别

var 不会产生块级作用域，会发生变量提升，可以在声明前就使用变量，值为 undefined。
let 和 const 会产生块级作用域，不会发生变量提升，不可以在声明前使用变量，会报错。
const 声明的变量不允许改变值，但是对于对象，可以更改对象的相关属性，因为存储的是对象的地址。

## 5. 请说出下列代码最终输出结果，并解释为什么？

var a = 10;
var obj = {
a: 20,
fn() {
setTimeout(() => {
console.log(this.a);
});
},
};
obj.fn();
回答：20
因为箭头函数没有 this，只能通过作用域链去查找 this，这里查找到的是 fn 的作用域，这里 fn 是被 obj 调用的，所以 this 指向 obj，所以 this.a 为 20

## 6. 简述 Symbol 类型的用途

定义一个不会重复的类型，例如当我们使用第三方的模块的时候，不清楚内部的逻辑，想要更改的时候就可能修改到内部的逻辑，导致一些 bug，此时就可以使用 Symbol 类型。

## 7. 说说什么是浅拷贝，什么是深拷贝？

浅拷贝只拷贝了第一层，对象内部的对象并没有拷贝，发生更改的时候仍然会影响源对象。
深拷贝就是不进拷贝了第一层，对于对象内部的对象也会进行拷贝，发生更改的时候不会影响源对象。

## 8. 请简述 TypeScript 与 JavaScript 之间的关系？

TS 是对于 JS 的增强，在 JS 的基础上多了一个类型系统，以及支持更高级的 JS 语法的使用。

## 9. 请谈谈你所认为的 typescript 优缺点

优点  
类型系统，能够帮助我们发现很多 bug
对于后续的扩展更有利
渐进式，可以慢慢学习是使用
功能更强大、生态更健全、更完善
缺点
需要学习很多概念和应用，有一定的学习成本
应用的时候需要编写很多额外的代码 ，很麻烦

## 10. 描述引用计数的工作原理和优缺点

通过一个引用计数器对对象进行标记，当被引用则该对象的引用计数+1，当出栈等操作导致引用结束，则引用计数-1，当为 0 的时候则标记为垃圾对象，可进行回收。
优点
引用计数为 0 的时候 引用计数立即回收 减少资源浪费
内存快要满的时候就会进行回收，减少程序卡顿，因为垃圾回收会阻断程序执行
缺点
无法处理循环引用的问题
资源消耗大

## 11. 描述标记整理算法的工作流程

从根开始遍历对象，进行标记
将标记的对象进行整理
遍历对象，对于未标记的对象进行回收

## 12. 描述 V8 中新生代存储区垃圾回收的流程

新生代分成等量的两份，成为 From 空间和 To 空间，当有活动对象的时候就会丢进 From 空间，然后进行标记整理，整理后将 From 空间的活动对象复制到 To 空间，然后 From 空间变成 To 空间，To 空间变成 From 空间，当 From 不足以存储新的活动对象的时候或者有经过一轮 GC 还仍然存在的活动对象的时候，就会发生晋升，从新生代移动到老生代中。

## 13. 描述增量标记算法在何时使用及工作原理

在分代回收中，老生代的内存位置比较大，所以如果一次性进行标记和回收花费的时间会很久，就会造成程序卡顿，用户感知到不流畅，所以采用增量标记的方式，与程序执行交错切换的执行。
